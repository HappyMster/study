专题-双指针
===
- 双指针问题出现的频率非常高，是性价比非常高的一类问题。

模板小结
---
- **首尾双指针**
    <div align="center"><img src="../_assets/TIM截图20180928102534.png" height="" /></div>
    
    - 一般用于寻找数组中满足条件的**两个数**；如果是寻找多个数，则先固定前 n-2 个数
    - 一般用于寻找数组/双向链表中满足条件的**两个节点**；如果是寻找多个数，则先固定前 n-2 个数；
    - 为了不遗漏所有可能情况，可能要求数组**有序**；
    - 遍历时，大于目标时 `hi--`，小于目标时 `lo++`。 
    - **典型问题**：[两数之和](#两数之和)、[三数之和](#三数之和)、[三角形计数](#三角形计数valid-triangle-number)
    
- **同向双指针**
    <div align="center"><img src="../_assets/TIM截图20180928102605.png" height="" /></div>
    
    - 一般用于寻找满足某个条件的**连续区间**
    - 在**链表**相关问题中经常会使用**快慢双指针**来寻找某个节点
    - **数组**中，一般用于寻找满足某个条件的**连续区间**；
    - **链表**相关问题中经常会使用**快慢双指针**来寻找某个节点；
    - **典型问题**：[最小覆盖子串](#最小覆盖子串minimum-window-substring)、[数组中的最长山脉（同向双指针）](#数组中的最长山脉longest-mountain-in-array同向双指针)

- **反向双指针**
    <div align="center"><img src="../_assets/TIM截图20180930171522.png" height="" /></div>

    - 先依次遍历都某个节点，然后使用双指针从该节点反向判断是否满足条件。
    - **典型问题**：[最长回文子串](#最长回文子串longest-palindromic-substring)、[数组中的最长山脉（反向双指针）](#数组中的最长山脉longest-mountain-in-array反向双指针)
    
- **分离双指针**
    <div align="center"><img src="../_assets/TIM截图20180928103003.png" height="" /></div>

@@ -24,11 +29,13 @@

    <div align="center"><img src="../_assets/TIM截图20180928103312.png" height="" /></div>

    - **典型问题**：[两个数组的交集](#两个数组的交集intersection-of-two-arrays)、[合并两个有序数组](#合并两个有序数组merge-sorted-array)

RoadMap
---
- [首尾双指针](#首尾双指针)
- [同向双指针](#同向双指针)
- [反向双指针](#反向双指针)
- [分离双指针](#分离双指针)
- [链表相关](#链表相关)
- [其他](#其他)
@@ -44,27 +51,33 @@ Index
          - [最接近的三数之和](#最接近的三数之和)
    - [两数之和 - 小于等于目标值的个数](#两数之和---小于等于目标值的个数)
    - [三数之和 - 小于等于目标值的个数](#三数之和---小于等于目标值的个数)
    - [三角形计数](#三角形计数)
    - [三角形计数（Valid Triangle Number）](#三角形计数valid-triangle-number)
    - [接雨水（Trapping Rain Water）（一维）](#接雨水trapping-rain-water一维)
    - [盛最多水的容器（Container With Most Water）](#盛最多水的容器container-with-most-water)
    - [反转字符串（Reverse String）](#反转字符串reverse-string)
    - [颜色分类（Sort Colors）](#颜色分类sort-colors)
- [同向双指针](#同向双指针)
    - [数组中的最长山脉（Longest Mountain in Array）](#数组中的最长山脉longest-mountain-in-array)
    - [数组中的最长山脉（Longest Mountain in Array）（同向双指针）](#数组中的最长山脉longest-mountain-in-array同向双指针)
    - [最小覆盖子串（Minimum Window Substring）](#最小覆盖子串minimum-window-substring)
    - [长度最小的子数组（Minimum Size Subarray Sum）](#长度最小的子数组minimum-size-subarray-sum)
    - [无重复字符的最长子串（Longest Substring Without Repeating Characters）](#无重复字符的最长子串longest-substring-without-repeating-characters)
    - [水果成篮（Fruit Into Baskets）](#水果成篮fruit-into-baskets)
- [反向双指针](#反向双指针)
    - [数组中的最长山脉（Longest Mountain in Array）（反向双指针）](#数组中的最长山脉longest-mountain-in-array反向双指针)
    - [最长回文子串（Longest Palindromic Substring）](#最长回文子串longest-palindromic-substring)
- [分离双指针](#分离双指针)
    - [两个数组的交集（Intersection of Two Arrays）](#两个数组的交集intersection-of-two-arrays)
        - [I](#i)
        - [II](#ii)
    - [合并两个有序数组（Merge Sorted Array）](#合并两个有序数组merge-sorted-array)
- [链表相关](#链表相关)
    - [分隔链表（Partition List）](#分隔链表partition-list)
    - [链表排序](#链表排序)
    - [链表排序（Sort List）](#链表排序sort-list)
        - [链表快排](#链表快排)
        - [链表归并](#链表归并)
        - [链表插入排序](#链表插入排序)
        - [链表选择排序](#链表选择排序)
        - [链表冒泡排序](#链表冒泡排序)
    - [旋转链表（Rotate List）](#旋转链表rotate-list)
- [其他](#其他)
    - [最小区间（Smallest Range）](#最小区间smallest-range)
    
<!-- /TOC -->

# 首尾双指针

## 两数之和
> LeetCode/[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/)
**问题描述**（167. 两数之和 II - 输入有序数组）
```python
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
说明:
    返回的下标值（index1 和 index2）不是从零开始的。
    你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
    
示例:
    输入: numbers = [2, 7, 11, 15], target = 9
    输出: [1,2]
    解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```
**拓展**
- 如果存在多个答案，并要求输出所有不重复的可能
    > [三数之和](#三数之和)
**思路 1**
- 首尾双指针
- 因为是有序的，可以尝试使用首尾双指针解决该问题，时间复杂度为 `O(N)`
- **Python**（双指针）
    ```python
    from typing import List

    第一种方法：
    def two_num(nums:List[int],target:int):
        for i in range(len(nums)):
            for j in nums[i+1:]:
                if nums[i]+j == target:
                    return True
        return False

    l = [1, 2, 4, 7, 11, 15]
    print(two_num(l,15))

    第二种方法：
    def two_num(nums, target):
        nums_dict = {}               # 字典存放（差值：下标）
        for i in range(len(nums)):
            temp = target- nums[i]
            if temp in nums_dict:
                return [nums_dict[temp],i]
            else:
                nums_dict[nums[i]] = i
    l = [1, 2, 4, 7, 11, 15]
    print(two_num(l,15))

    第三种方法：
    def twonum(nums, target):
        # nums.sort()
        left = 0
        right = len(nums)-1
        while left < right:
            curr = nums[left] + nums[right]
            if curr == target:
                print(nums[left], nums[right])
                left += 1
                right -= 1
                break
            else:
                if curr < target:
                    left += 1
                else:
                    right -= 1
    l = [1, 2, 4, 7, 11, 15]
    twonum(l, 15)
     ```

    
    
    
    
    
